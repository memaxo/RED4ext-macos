#!/usr/bin/env python3
"""
Convert Addresses.hpp to addresses.json format

This script reads:
1. Addresses.hpp (generated by find_patterns.py) - contains function names and offsets
2. AddressHashes.hpp (from SDK) - contains hash constants for function names
3. Outputs addresses.json in the correct format

Usage:
    python3 convert_addresses_hpp_to_json.py <Addresses.hpp> [--hashes <AddressHashes.hpp>] [--output <output.json>]
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, Optional, Tuple


def parse_addresses_hpp(hpp_path: Path) -> Dict[str, int]:
    """
    Parse Addresses.hpp to extract function names and offsets.
    Format: constexpr uintptr_t Name = 0x12345678 - ImageBase;
    Returns dict mapping name -> offset (relative to ImageBase).
    """
    if not hpp_path.exists():
        return {}
    
    content = hpp_path.read_text()
    addresses = {}
    
    # Match: constexpr uintptr_t Name = 0x12345678 - ImageBase;
    pattern = r'constexpr\s+uintptr_t\s+(\w+)\s*=\s*0x([0-9A-Fa-f]+)\s*-\s*ImageBase\s*;'
    
    for match in re.finditer(pattern, content):
        name = match.group(1)
        offset_str = match.group(2)
        try:
            offset = int(offset_str, 16)
            addresses[name] = offset
        except ValueError:
            continue
    
    return addresses


def parse_address_hashes_hpp(hpp_path: Path) -> Dict[str, int]:
    """
    Parse AddressHashes.hpp to extract hash constants.
    Format: constexpr std::uint32_t Name = 0x12345678UL;
    Returns dict mapping name -> hash value.
    """
    if not hpp_path.exists():
        return {}
    
    content = hpp_path.read_text()
    hashes = {}
    
    # Match: constexpr std::uint32_t Name = 0x12345678UL;
    pattern = r'constexpr\s+std::uint32_t\s+(\w+)\s*=\s*(0x[0-9A-Fa-f]+|\d+)[UuLl]*\s*;'
    
    for match in re.finditer(pattern, content):
        name = match.group(1)
        value_str = match.group(2)
        try:
            if value_str.startswith('0x'):
                value = int(value_str, 16)
            else:
                value = int(value_str)
            hashes[name] = value & 0xFFFFFFFF
        except ValueError:
            continue
    
    return hashes


def determine_segment(offset: int, code_size: int = 0x10000000, data_const_size: int = 0x1000000) -> Tuple[int, int]:
    """
    Determine which segment an offset belongs to.
    Returns (segment_num, relative_offset).
    
    Segment mapping:
    1 = __TEXT (code) - typically 0x00000000 - 0x0FFFFFFF
    2 = __DATA_CONST (read-only data) - typically 0x10000000 - 0x10FFFFFF
    3 = __DATA (read-write data) - typically 0x11000000 - 0x11FFFFFF
    
    This is a simplification - real implementation would check actual segment ranges.
    """
    # Simple heuristic: assume offsets < 0x10000000 are code
    if offset < 0x10000000:
        return (1, offset)  # Segment 1 = __TEXT
    elif offset < 0x11000000:
        return (2, offset - 0x10000000)  # Segment 2 = __DATA_CONST
    else:
        return (3, offset - 0x11000000)  # Segment 3 = __DATA


def convert_to_json(
    addresses_hpp_path: Path,
    hashes_hpp_path: Optional[Path] = None,
    output_path: Path = Path('cyberpunk2077_addresses.json'),
    game_version: str = '2.3.1'
) -> int:
    """
    Convert Addresses.hpp to addresses.json format.
    Returns 0 on success, 1 on error.
    """
    print(f"Converting {addresses_hpp_path} to addresses.json...")
    
    # Parse Addresses.hpp
    addresses = parse_addresses_hpp(addresses_hpp_path)
    print(f"Found {len(addresses)} addresses in Addresses.hpp")
    
    if not addresses:
        print("Error: No addresses found in Addresses.hpp", file=sys.stderr)
        return 1
    
    # Parse AddressHashes.hpp (if provided)
    hash_constants = {}
    if hashes_hpp_path:
        hash_constants = parse_address_hashes_hpp(hashes_hpp_path)
        print(f"Found {len(hash_constants)} hash constants in AddressHashes.hpp")
    else:
        # Try to find SDK AddressHashes.hpp
        sdk_hash_path = Path(__file__).parent.parent.parent / 'RED4ext.SDK' / 'include' / 'RED4ext' / 'Detail' / 'AddressHashes.hpp'
        if sdk_hash_path.exists():
            hash_constants = parse_address_hashes_hpp(sdk_hash_path)
            print(f"Found {len(hash_constants)} hash constants in SDK AddressHashes.hpp")
    
    if not hash_constants:
        print("Warning: No hash constants found - addresses.json will have placeholder hashes", file=sys.stderr)
    
    # Generate JSON entries
    json_entries = []
    matched_count = 0
    
    for name, offset in addresses.items():
        # Try to find matching hash
        hash_value = hash_constants.get(name)
        
        if hash_value is None:
            # Skip entries without hash constants
            print(f"  âš  {name}: no hash constant found, skipping")
            continue
        
        # Determine segment
        segment_num, rel_offset = determine_segment(offset)
        
        json_entries.append({
            "hash": f"0x{hash_value:08X}",
            "offset": f"{segment_num}:0x{rel_offset:X}"
        })
        matched_count += 1
    
    # Generate JSON output
    json_data = {
        "version": "1.0",
        "game_version": game_version,
        "Addresses": json_entries
    }
    
    # Write output
    with open(output_path, 'w') as f:
        json.dump(json_data, f, indent=2)
    
    print(f"\nGenerated {len(json_entries)} address entries ({matched_count} matched with hash constants)")
    print(f"Output written to: {output_path}")
    
    if matched_count < len(addresses):
        print(f"\nWarning: {len(addresses) - matched_count} addresses skipped (no hash constant)")
    
    return 0


def main():
    parser = argparse.ArgumentParser(
        description='Convert Addresses.hpp to addresses.json format'
    )
    parser.add_argument(
        'addresses_hpp',
        type=Path,
        help='Path to Addresses.hpp (generated by find_patterns.py)'
    )
    parser.add_argument(
        '--hashes', '-H',
        type=Path,
        help='Path to AddressHashes.hpp (optional, will try to find SDK version if not provided)'
    )
    parser.add_argument(
        '--output', '-o',
        type=Path,
        default=Path('cyberpunk2077_addresses.json'),
        help='Output JSON file path (default: cyberpunk2077_addresses.json)'
    )
    parser.add_argument(
        '--game-version',
        type=str,
        default='2.3.1',
        help='Game version string (default: 2.3.1)'
    )
    
    args = parser.parse_args()
    
    if not args.addresses_hpp.exists():
        print(f"Error: Addresses.hpp not found: {args.addresses_hpp}", file=sys.stderr)
        sys.exit(1)
    
    exit_code = convert_to_json(
        args.addresses_hpp,
        args.hashes,
        args.output,
        args.game_version
    )
    
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
